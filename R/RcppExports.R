# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' pick_new_bugs
#'
#' Sampling function for growth_one_group(), growth()
#' @param arr is a vector of positions. If the abundance vector of interest has
#' 5 members, x must be [1 2 3 4 5].
#' @export
pick_new_bugs <- function(arr, size, replace, prob) {
    .Call(`_dilgrowth_pick_new_bugs`, arr, size, replace, prob)
}

#' growth_one_group
#'
#' This Rcpp function simulates the growth of a community of organisms over a
#' specified time step. It takes the current community abundances, a fixed
#' growth step, and an optional interactions matrix as inputs, and returns
#' an updated abundances vector that reflects the growth of the community. The
#' function calculates the probability of growth for each organism based on
#' their current abundance and any specified interactions between organisms. The
#' function then randomly selects organisms to grow based on these probabilities
#' and increases their abundance by growth_step (1 by default).
#' The function takes four arguments:
#' @param this_timestep A numeric vector representing the current abundance of
#' each organism in the population.
#' @param growth_step An integer representing the growth step for organisms in
#' the community, 1 by default.
#' @param interactions An optional numeric matrix representing the interaction
#' between organisms in the population. This argument is set to R_NilValue by
#' default.
#' @export
growth_one_group <- function(this_timestep, growth_step, interactions = NULL) {
    .Call(`_dilgrowth_growth_one_group`, this_timestep, growth_step, interactions)
}

#' growth
#'
#' This function simulates growth in a community by looking at the carrying
#' capacities of the group they belong to. It takes a named vector,
#' carrying_capacities.
#'
#' Growth is RANDOM: all species have the opportunity to grow each
#' time this function is called, but whether they will is random and depends on
#' their abundance. Their growth probability varies depending not only on their
#' abundances but also on their carrying capacity. Growth is not logistic.
#'
#' As opposed to growth_one_group(), the growth rate (probability of being
#' picked for growth) is determined for each individual by the carrying
#' capacity of its group(\[growth_step * group's % of total carrying capacity]).
#' An optionally passed interactions matrix has an effect as well. Every group
#' will have growth_step (by default 1) of its present individuals grow in each
#' run, and they can be from the same ASV/OTU/species or not. Also, growth step
#' is proportional to the carrying capacity of its group. This is to avoid group
#' extinction and also to ensure growth has a similar, proportional rate for
#' each group so all groups reach their CC at the same time.
#'`
#' @export
growth <- function(x, carrying_capacities, growth_step, interactions = NULL) {
    .Call(`_dilgrowth_growth`, x, carrying_capacities, growth_step, interactions)
}

#' growth_log
#'
#' This function simulates growth in a community by looking at the carrying
#' capacities of the group they belong to. It takes a named vector,
#' carrying_capacities.
#'
#' Growth is RANDOM but logistic: all species have the opportunity to grow each
#' time this function is called, but whether they will is random and depends on
#' their abundance (random). Their growth probability varies depending not
#' only on their abundances but also on their carrying capacity.
#'
#' As opposed to growth_one_group(), the growth rate is given by a logistic
#' function and not growth_step. Another difference is that growing species are
#' not chosen one by one by sampling, but with a binomial function. That means
#' that the number of different species and the number of individuals that can
#' grow in each iteration of this function is not limited.
#'
#' The difference with growth() is that growth is logistic in this function and
#' there is not growth_step here.
#'
#' If the carrying capacity for a group was surpassed before starting the
#' growth cycle, the species of that group will die at a proportionate rate,
#' while the others may grow.
#'
#' @export
growth_log <- function(x, carrying_capacities, interactions = NULL) {
    .Call(`_dilgrowth_growth_log`, x, carrying_capacities, interactions)
}

#' check_step
#'
#' Checks if a given growth_step is ok for running a growth() function and adjusts
#' it accordingly if it's not (for example not allowing for it to cause too big
#' of a growth, surpassing total wanted final community abundance).
#' @param is_growth_step_a_perc Boolean: if false, growth_step is taken as a fixed
#' value, so the step will always be the same. If true, it is taken to indicate
#' a percentage - the step will be changed proportionally to the community size.
#' If growth_step is 0.02, 2% of the members in the community will grow the next
#' iteration
#' @export
check_step <- function(this_timestep, abun_total, growth_step, is_growth_step_a_perc = FALSE) {
    .Call(`_dilgrowth_check_step`, this_timestep, abun_total, growth_step, is_growth_step_a_perc)
}

#' full_growth
#'
#' This function consists in a loop that runs growth(...)() functions as many
#' times as needed to reach a given population size.
#' @export
full_growth <- function(this_timestep, abun_total, growth_step, is_growth_step_a_perc = FALSE, func = "growth", interactions = NULL, carrying_capacities = NULL) {
    .Call(`_dilgrowth_full_growth`, this_timestep, abun_total, growth_step, is_growth_step_a_perc, func, interactions, carrying_capacities)
}

